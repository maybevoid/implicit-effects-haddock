-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Algebraic Effects in Haskell using Implicit Parameters
--   
--   implicit-effects is a experimental effect library to support algebraic
--   effects in Haskell.
@package implicit-effects
@version 0.1.0

module Control.Effect.Implicit.Base.EffSpec
class EffSpec (sig :: Type) where {
    
    -- | The operation type for <tt>ops</tt> is consumed by computations to
    --   perform effect operations. The type is indexed by an <tt>Effect</tt>
    --   type <tt>eff</tt> that indicates under which monad can the operations
    --   be performed. <tt><a>Operation</a> ops</tt> must be an
    --   <tt>EffFunctor</tt> to lift effect operations to work on any lifted
    --   monad. This is similar to how lifting works in MonadTrans, except here
    --   we are lifting the operations manually instead of through typeclasses.
    type family Operation sig = (ops :: (Type -> Type) -> Type) | ops -> sig;
    
    -- | The co-operation type for <tt>ops</tt> is produced by computations
    --   when they perform effect operations under a free monad, and is used by
    --   effect interpreters such as <a>CoOpHandler</a> to interpret effect
    --   operations from a free monad. <tt>'CoOperation ops'</tt> must be a
    --   functor so that we can use it as the payload type in free monads such
    --   as <a>ChurchMonad</a> or <a>FreeMonad</a>
    type family CoOperation sig = (coop :: (Type -> Type)) | coop -> sig;
}

module Control.Effect.Implicit.Base.Effect

-- | A less scary type alias to <a>Monad</a>. We hope that implicit-effects
--   can help Haskell beginners to learn how to better structure effectful
--   programs without first going through all the struggles of
--   understanding the machineries of monad, monad transformers, free
--   monad, extensible effects, etc before they can properly write a "good"
--   effectful program. Instead beginners should be taught from first
--   principles about algebraic effects, and go through something similar
--   to the <a>Eff language tutorial</a>, which does a great job explaning
--   algebraic effects without mentioning the M-word.
type Effect eff = Monad eff

module Control.Effect.Implicit.Base.EffFunctor

-- | An <a>EffFunctor</a> <tt>comp</tt> is parameterized by an
--   <a>Effect</a> <tt>eff1</tt> and can be lifted to another <a>Effect</a>
--   <tt>eff2</tt> by providing a natural transformation <tt>eff1 ~&gt;
--   eff2</tt> to <a>effmap</a>. A simple example for <tt>comp</tt> is
--   <a>Return</a>.
class EffFunctor (comp :: (Type -> Type) -> Type)

-- | Lift a computation <tt>comp</tt> from <a>Effect</a> <tt>eff1</tt> to
--   <tt>eff2</tt> through the given natural transformation.
effmap :: forall eff1 eff2. (EffFunctor comp, Effect eff1, Effect eff2) => (forall x. eff1 x -> eff2 x) -> comp eff1 -> comp eff2

module Control.Effect.Implicit.Base.FreeOps

-- | A <a>FreeOps</a> <tt>ops</tt> has associated types that can be used
--   for effect operations and interpretations. We typically use dummy
--   datatypes with empty declaration for <tt>ops</tt> to signify that
--   <tt>ops</tt> is only used for tagging effects and are not used at the
--   value level.
class (EffSpec ops, Functor (CoOperation ops), EffFunctor (Operation ops)) => FreeOps (ops :: Type)

-- | The free ops constructor is used for generating free operations that
--   can work under any free monad transformer <tt>t</tt> and any
--   <a>Effect</a> <tt>eff</tt>. It is given a payload lifter that can lift
--   a <tt><a>CoOperation</a> ops</tt> into the free monad transformed
--   effect <tt>t eff</tt>, which can be used to construct a free
--   <tt><a>Operation</a> ops</tt> under the effect <tt>t eff</tt>.
--   <a>mkFreeOps</a> is used by <a>FreeEff</a> instances so that they can
--   create a free operation for any free monad.
mkFreeOps :: forall t eff. (FreeOps ops, Effect eff, Effect (t eff)) => (forall a. CoOperation ops a -> t eff a) -> Operation ops (t eff)

module Control.Effect.Implicit.Base.Implicit

-- | An effect operation must also be an instance of <tt>EffOps</tt> to
--   give computations access to <tt><a>Operation</a> ops</tt> through
--   implicit parameter constraints. The <tt>FreeOps</tt> class hides the
--   machinery of implicit parameters and make them appear like regular
--   constraints with local scope. The definition for <tt>EffOps</tt> for
--   most effect operations can typically be derived mechanically. We may
--   look into using template Haskell to generate instances for
--   <tt>EffOps</tt> in future to reduce the boilerplate.
--   
--   The law for <tt>EffOps</tt> is
--   
--   <pre>
--   forall ops . <a>withOps</a> ops <a>captureOps</a> === ops
--   </pre>
--   
--   This means any non-trivial instance for <tt>EffOps</tt> must somehow
--   make use of implicit parameters for the law to hold.
class (EffSpec ops) => ImplicitOps ops where {
    
    -- | The constraint kind for the effect operation under <a>Effect</a>
    --   <tt>eff</tt>. This is typically an implicit parameter with a unique
    --   name, e.g. <tt>type OpsConstraint FooEff eff = (?fooOps :: Operation
    --   FooEff eff)</tt>. Note that there is a injective type families
    --   condition, and given that implicit parameters have a single namespace,
    --   users must come out with naming conventions for their custom effects
    --   to avoid name clashing that would result in compile-time injectivity
    --   violation error.
    type family OpsConstraint ops (eff :: Type -> Type) = (c :: Constraint) | c -> ops eff;
}

-- | Takes an effect operation <tt><a>Operation</a> ops eff</tt> and bind
--   it to the implicit parameter specified in <tt><a>OpsConstraint</a> ops
--   eff</tt> for the continuation <tt>r</tt>. The expression <tt>r</tt>
--   can then use the effect operations without having to explicitly pass
--   them around as function arguments. For the example <tt>FooEff</tt>,
--   the body for <a>withOps</a> can be defined as <tt>withOps fooOps cont
--   = let ?fooOps = fooOps in cont </tt>.
withOps :: forall eff r. (ImplicitOps ops, Effect eff) => Operation ops eff -> (OpsConstraint ops eff => r) -> r

-- | If an implicit parameter for the effect operation is available in the
--   context, capture it and return the operation as a value. For the
--   example <tt>FooEff</tt>, the body for <a>captureOps</a> can be defined
--   as <tt>captureOps = ?fooOps</tt>.
captureOps :: forall eff. (ImplicitOps ops, Effect eff, OpsConstraint ops eff) => Operation ops eff

-- | This is a type alias for the implicit parameter constraint for
--   <tt>ops</tt>, in addition to requiring <tt>eff</tt> to be an
--   <a>Effect</a>. This helps reducing boilerplate in generic computations
--   so that we do not have to keep repeating the <tt>(Effect eff)</tt>
--   constraint in our type signatures.
type EffConstraint ops eff = (Effect eff, OpsConstraint ops eff)

module Control.Effect.Implicit.Base.EffOps
class (ImplicitOps ops, FreeOps ops) => EffOps ops
instance (Control.Effect.Implicit.Base.Implicit.ImplicitOps ops, Control.Effect.Implicit.Base.FreeOps.FreeOps ops) => Control.Effect.Implicit.Base.EffOps.EffOps ops

module Control.Effect.Implicit.Base.LiftEff

-- | An opaque object-ish effect lifter that can apply <a>effmap</a> to an
--   <a>EffFunctor</a>. We define dedicated datatype instead of using the
--   natural transformation <tt>(~&gt;)</tt> so that in the case of
--   identity, we can construct a special <a>idLift</a> that skip calling
--   <tt><a>effmap</a> id</tt> and return the original <a>EffFunctor</a>.
--   This may save a bit on creating redundant <a>Operation</a> and
--   <a>CoOperation</a> objects during <tt><a>effmap</a> id</tt>,
--   particularly when they are used together with <a>Computation</a>.
data LiftEff (eff1 :: (Type -> Type)) (eff2 :: (Type -> Type))

-- | An optimized version of <a>LiftEff</a> when there is no effect lifting
--   required, e.g. when we want to execute a <a>Computation</a> with its
--   original effect.
idLift :: forall eff. Effect eff => LiftEff eff eff

-- | Create a <a>LiftEff</a> from a natural transformation <tt>eff1 ~&gt;
--   eff2</tt>. This assumes <tt>eff1</tt> and <tt>eff2</tt> are different,
--   as otherwise we can use <a>idLift</a> for optimized version of
--   <a>LiftEff</a>.
mkLiftEff :: forall eff1 eff2. (Effect eff1, Effect eff2) => (forall x. eff1 x -> eff2 x) -> LiftEff eff1 eff2

-- | The base natural transformation that can be extracted
liftEff :: LiftEff eff1 eff2 -> forall x. eff1 x -> eff2 x

-- | When applying effect lifting to an <a>EffFunctor</a>,
--   <a>applyEffmap</a> should be used instead of calling <a>effmap</a>
--   directly. This could potentially save some unnecesssary objects
--   recreation in the case of <a>idLift</a>.
applyEffmap :: LiftEff eff1 eff2 -> forall comp. EffFunctor comp => comp eff1 -> comp eff2

-- | An optimizable composition of two natural transformations. This makes
--   sure the no new <a>LiftEff</a> is created when either side is
--   <a>idLift</a>. The behavior for <a>joinLift</a> is as follow:
--   
--   <pre>
--   <a>joinLift</a> idLift idLift === idLift
--   <a>joinLift</a> idLift lift2 === lift2
--   <a>joinLift</a> lift1 idLift === lift1
--   <a>joinLift</a> lift1 lift2 === <a>mkLiftEff</a> $ (liftEff lift2) . (liftEff lift1)
--   </pre>
joinLift :: LiftEff eff1 eff2 -> forall eff3. Effect eff3 => LiftEff eff2 eff3 -> LiftEff eff1 eff3

module Control.Effect.Implicit.Base.NoEff

-- | The trivial effect <a>NoEff</a> have singleton operation and can be
--   trivially satisfied for all <tt>Effect</tt> <tt>eff</tt>. It is the
--   identity for the <tt>Control.Effect.Implicit.Base.Union</tt> type
--   operator such that:
--   
--   <pre>
--   forall ops . ops <a>∪</a> <a>NoEff</a> ~= <a>NoEff</a> <a>∪</a> ops ~= ops
--   </pre>
--   
--   which by <tt>ops1 ~= ops2</tt> means <tt>ops1 <a>⊇</a> ops2</tt> and
--   <tt>ops2 <a>⊇</a> ops1</tt>, i.e. they satisfies equivalent set of
--   <tt>OpsConstraints</tt> up to casting equivalents by <a>OpsCast</a>.
data NoEff

-- | <tt><a>Operation</a> <a>NoEff</a> eff</tt> is really just <tt>()</tt>
--   for all <tt>Effect</tt> <tt>eff</tt>. We instead define <a>NoOp</a>
--   with phantom type <tt>eff</tt> so that the injectivity condition for
--   <a>Operation</a> can be satisfied.
data NoOp (eff :: Type -> Type)
NoOp :: NoOp

-- | <tt><a>CoOperation</a> <a>NoEff</a> r</tt> is really just <tt>()</tt>
--   for all return type <tt>r</tt>. We instead define <a>NoCoOp</a> with
--   phantom type <tt>r</tt> so that the injectivity condition for
--   <a>CoOperation</a> can be satisfied.
data NoCoOp r
NoCoOp :: NoCoOp r

-- | <tt><a>OpsConstraint</a> <a>NoEff</a> eff</tt> is just the empty
--   constraint <tt>()</tt> for all <tt>Effect</tt> <tt>eff</tt>. We
--   instead define the empty class <a>NoConstraint</a> with trivial
--   instance for all <tt>Effect</tt> <tt>eff</tt> so that the injectivity
--   condition for <a>OpsConstraint</a> can be satisfied.
class NoConstraint (eff :: Type -> Type)
instance Control.Effect.Implicit.Base.NoEff.NoConstraint eff
instance Control.Effect.Implicit.Base.Implicit.ImplicitOps Control.Effect.Implicit.Base.NoEff.NoEff
instance Control.Effect.Implicit.Base.EffSpec.EffSpec Control.Effect.Implicit.Base.NoEff.NoEff
instance GHC.Base.Functor Control.Effect.Implicit.Base.NoEff.NoCoOp
instance Control.Effect.Implicit.Base.EffFunctor.EffFunctor Control.Effect.Implicit.Base.NoEff.NoOp
instance Control.Effect.Implicit.Base.FreeOps.FreeOps Control.Effect.Implicit.Base.NoEff.NoEff

module Control.Effect.Implicit.Base.Union

-- | Combines two effect operations into a new effect operation. Union can
--   be used multiple times to combine multiple effect operations into one.
data Union ops1 ops2
infixr 7 `Union`

-- | Right associative term operator alias for <a>UnionOps</a>, e.g.
--   
--   <pre>
--   forall ops1 ops2 ops3 .
--     ops1 ∪ ops2 ∪ ops3 === UnionOps ops1 (UnionOps ops2 ops3)
--   </pre>
(∪) :: forall ops1 ops2 eff. ops1 eff -> ops2 eff -> UnionOps ops1 ops2 eff
infixr 7 ∪

-- | The <a>Operation</a> of <tt>ops1 <a>∪</a> ops2</tt> undef effect
--   <tt>eff</tt> is the product of the underlying <tt><a>Operation</a>
--   ops1 eff</tt> and <tt><a>Operation</a> ops2 eff</tt>.
data UnionOps ops1 ops2 (eff :: Type -> Type)
UnionOps :: ops1 eff -> ops2 eff -> UnionOps ops1 ops2
infixr 7 `UnionOps`
infixr 7 `UnionOps`

-- | Right associative type operator alias for <a>Union</a>, e.g.
--   
--   <pre>
--   forall ops1 ops2 ops3 :: Type .
--     ops1 ∪ ops2 ∪ ops3 === Union ops1 (Union ops2 ops3)
--   </pre>
type (∪) = Union
infixr 7 ∪

-- | The <a>CoOperation</a> of <tt>ops1 <a>∪</a> ops2</tt> under return
--   type <tt>r</tt> is the sum of the underlying <tt><a>CoOperation</a>
--   ops1 r</tt> and <tt><a>CoOperation</a> ops2 r</tt>.
data UnionCoOp ops1 ops2 r
LeftCoOp :: ops1 r -> UnionCoOp ops1 ops2 r
RightCoOp :: ops2 r -> UnionCoOp ops1 ops2 r

-- | Get the left operation of the <tt><a>Operation</a> (ops1 <a>∪</a>
--   ops2)</tt> product.
leftOps :: forall ops1 ops2 eff. UnionOps ops1 ops2 eff -> ops1 eff

-- | Get the right operation of the <tt><a>Operation</a> (ops1 <a>∪</a>
--   ops2)</tt> product.
rightOps :: forall ops1 ops2 eff. UnionOps ops1 ops2 eff -> ops2 eff
instance Control.Effect.Implicit.Base.EffSpec.EffSpec (Control.Effect.Implicit.Base.Union.Union ops1 ops2)
instance (GHC.Base.Functor ops1, GHC.Base.Functor ops2) => GHC.Base.Functor (Control.Effect.Implicit.Base.Union.UnionCoOp ops1 ops2)
instance (Control.Effect.Implicit.Base.FreeOps.FreeOps ops1, Control.Effect.Implicit.Base.FreeOps.FreeOps ops2) => Control.Effect.Implicit.Base.FreeOps.FreeOps (Control.Effect.Implicit.Base.Union.Union ops1 ops2)
instance (Control.Effect.Implicit.Base.EffFunctor.EffFunctor ops1, Control.Effect.Implicit.Base.EffFunctor.EffFunctor ops2) => Control.Effect.Implicit.Base.EffFunctor.EffFunctor (Control.Effect.Implicit.Base.Union.UnionOps ops1 ops2)
instance (Control.Effect.Implicit.Base.Implicit.ImplicitOps ops1, Control.Effect.Implicit.Base.Implicit.ImplicitOps ops2) => Control.Effect.Implicit.Base.Implicit.ImplicitOps (Control.Effect.Implicit.Base.Union.Union ops1 ops2)


-- | Base module that defines the basic datatypes for implicit-effects.
module Control.Effect.Implicit.Base

-- | A less scary type alias to <a>Monad</a>. We hope that implicit-effects
--   can help Haskell beginners to learn how to better structure effectful
--   programs without first going through all the struggles of
--   understanding the machineries of monad, monad transformers, free
--   monad, extensible effects, etc before they can properly write a "good"
--   effectful program. Instead beginners should be taught from first
--   principles about algebraic effects, and go through something similar
--   to the <a>Eff language tutorial</a>, which does a great job explaning
--   algebraic effects without mentioning the M-word.
type Effect eff = Monad eff

-- | An <a>EffFunctor</a> <tt>comp</tt> is parameterized by an
--   <a>Effect</a> <tt>eff1</tt> and can be lifted to another <a>Effect</a>
--   <tt>eff2</tt> by providing a natural transformation <tt>eff1 ~&gt;
--   eff2</tt> to <a>effmap</a>. A simple example for <tt>comp</tt> is
--   <a>Return</a>.
class EffFunctor (comp :: (Type -> Type) -> Type)

-- | Lift a computation <tt>comp</tt> from <a>Effect</a> <tt>eff1</tt> to
--   <tt>eff2</tt> through the given natural transformation.
effmap :: forall eff1 eff2. (EffFunctor comp, Effect eff1, Effect eff2) => (forall x. eff1 x -> eff2 x) -> comp eff1 -> comp eff2
class EffSpec (sig :: Type) where {
    
    -- | The operation type for <tt>ops</tt> is consumed by computations to
    --   perform effect operations. The type is indexed by an <tt>Effect</tt>
    --   type <tt>eff</tt> that indicates under which monad can the operations
    --   be performed. <tt><a>Operation</a> ops</tt> must be an
    --   <tt>EffFunctor</tt> to lift effect operations to work on any lifted
    --   monad. This is similar to how lifting works in MonadTrans, except here
    --   we are lifting the operations manually instead of through typeclasses.
    type family Operation sig = (ops :: (Type -> Type) -> Type) | ops -> sig;
    
    -- | The co-operation type for <tt>ops</tt> is produced by computations
    --   when they perform effect operations under a free monad, and is used by
    --   effect interpreters such as <a>CoOpHandler</a> to interpret effect
    --   operations from a free monad. <tt>'CoOperation ops'</tt> must be a
    --   functor so that we can use it as the payload type in free monads such
    --   as <a>ChurchMonad</a> or <a>FreeMonad</a>
    type family CoOperation sig = (coop :: (Type -> Type)) | coop -> sig;
}

-- | An effect operation must also be an instance of <tt>EffOps</tt> to
--   give computations access to <tt><a>Operation</a> ops</tt> through
--   implicit parameter constraints. The <tt>FreeOps</tt> class hides the
--   machinery of implicit parameters and make them appear like regular
--   constraints with local scope. The definition for <tt>EffOps</tt> for
--   most effect operations can typically be derived mechanically. We may
--   look into using template Haskell to generate instances for
--   <tt>EffOps</tt> in future to reduce the boilerplate.
--   
--   The law for <tt>EffOps</tt> is
--   
--   <pre>
--   forall ops . <a>withOps</a> ops <a>captureOps</a> === ops
--   </pre>
--   
--   This means any non-trivial instance for <tt>EffOps</tt> must somehow
--   make use of implicit parameters for the law to hold.
class (EffSpec ops) => ImplicitOps ops where {
    
    -- | The constraint kind for the effect operation under <a>Effect</a>
    --   <tt>eff</tt>. This is typically an implicit parameter with a unique
    --   name, e.g. <tt>type OpsConstraint FooEff eff = (?fooOps :: Operation
    --   FooEff eff)</tt>. Note that there is a injective type families
    --   condition, and given that implicit parameters have a single namespace,
    --   users must come out with naming conventions for their custom effects
    --   to avoid name clashing that would result in compile-time injectivity
    --   violation error.
    type family OpsConstraint ops (eff :: Type -> Type) = (c :: Constraint) | c -> ops eff;
}

-- | Takes an effect operation <tt><a>Operation</a> ops eff</tt> and bind
--   it to the implicit parameter specified in <tt><a>OpsConstraint</a> ops
--   eff</tt> for the continuation <tt>r</tt>. The expression <tt>r</tt>
--   can then use the effect operations without having to explicitly pass
--   them around as function arguments. For the example <tt>FooEff</tt>,
--   the body for <a>withOps</a> can be defined as <tt>withOps fooOps cont
--   = let ?fooOps = fooOps in cont </tt>.
withOps :: forall eff r. (ImplicitOps ops, Effect eff) => Operation ops eff -> (OpsConstraint ops eff => r) -> r

-- | If an implicit parameter for the effect operation is available in the
--   context, capture it and return the operation as a value. For the
--   example <tt>FooEff</tt>, the body for <a>captureOps</a> can be defined
--   as <tt>captureOps = ?fooOps</tt>.
captureOps :: forall eff. (ImplicitOps ops, Effect eff, OpsConstraint ops eff) => Operation ops eff

-- | A <a>FreeOps</a> <tt>ops</tt> has associated types that can be used
--   for effect operations and interpretations. We typically use dummy
--   datatypes with empty declaration for <tt>ops</tt> to signify that
--   <tt>ops</tt> is only used for tagging effects and are not used at the
--   value level.
class (EffSpec ops, Functor (CoOperation ops), EffFunctor (Operation ops)) => FreeOps (ops :: Type)

-- | The free ops constructor is used for generating free operations that
--   can work under any free monad transformer <tt>t</tt> and any
--   <a>Effect</a> <tt>eff</tt>. It is given a payload lifter that can lift
--   a <tt><a>CoOperation</a> ops</tt> into the free monad transformed
--   effect <tt>t eff</tt>, which can be used to construct a free
--   <tt><a>Operation</a> ops</tt> under the effect <tt>t eff</tt>.
--   <a>mkFreeOps</a> is used by <a>FreeEff</a> instances so that they can
--   create a free operation for any free monad.
mkFreeOps :: forall t eff. (FreeOps ops, Effect eff, Effect (t eff)) => (forall a. CoOperation ops a -> t eff a) -> Operation ops (t eff)
class (ImplicitOps ops, FreeOps ops) => EffOps ops

-- | This is a type alias for the implicit parameter constraint for
--   <tt>ops</tt>, in addition to requiring <tt>eff</tt> to be an
--   <a>Effect</a>. This helps reducing boilerplate in generic computations
--   so that we do not have to keep repeating the <tt>(Effect eff)</tt>
--   constraint in our type signatures.
type EffConstraint ops eff = (Effect eff, OpsConstraint ops eff)

-- | The trivial effect <a>NoEff</a> have singleton operation and can be
--   trivially satisfied for all <tt>Effect</tt> <tt>eff</tt>. It is the
--   identity for the <tt>Control.Effect.Implicit.Base.Union</tt> type
--   operator such that:
--   
--   <pre>
--   forall ops . ops <a>∪</a> <a>NoEff</a> ~= <a>NoEff</a> <a>∪</a> ops ~= ops
--   </pre>
--   
--   which by <tt>ops1 ~= ops2</tt> means <tt>ops1 <a>⊇</a> ops2</tt> and
--   <tt>ops2 <a>⊇</a> ops1</tt>, i.e. they satisfies equivalent set of
--   <tt>OpsConstraints</tt> up to casting equivalents by <a>OpsCast</a>.
data NoEff

-- | Combines two effect operations into a new effect operation. Union can
--   be used multiple times to combine multiple effect operations into one.
data Union ops1 ops2
infixr 7 `Union`

-- | An opaque object-ish effect lifter that can apply <a>effmap</a> to an
--   <a>EffFunctor</a>. We define dedicated datatype instead of using the
--   natural transformation <tt>(~&gt;)</tt> so that in the case of
--   identity, we can construct a special <a>idLift</a> that skip calling
--   <tt><a>effmap</a> id</tt> and return the original <a>EffFunctor</a>.
--   This may save a bit on creating redundant <a>Operation</a> and
--   <a>CoOperation</a> objects during <tt><a>effmap</a> id</tt>,
--   particularly when they are used together with <a>Computation</a>.
data LiftEff (eff1 :: (Type -> Type)) (eff2 :: (Type -> Type))

-- | Right associative type operator alias for <a>Union</a>, e.g.
--   
--   <pre>
--   forall ops1 ops2 ops3 :: Type .
--     ops1 ∪ ops2 ∪ ops3 === Union ops1 (Union ops2 ops3)
--   </pre>
type (∪) = Union
infixr 7 ∪

-- | <tt><a>Operation</a> <a>NoEff</a> eff</tt> is really just <tt>()</tt>
--   for all <tt>Effect</tt> <tt>eff</tt>. We instead define <a>NoOp</a>
--   with phantom type <tt>eff</tt> so that the injectivity condition for
--   <a>Operation</a> can be satisfied.
data NoOp (eff :: Type -> Type)
NoOp :: NoOp

-- | <tt><a>CoOperation</a> <a>NoEff</a> r</tt> is really just <tt>()</tt>
--   for all return type <tt>r</tt>. We instead define <a>NoCoOp</a> with
--   phantom type <tt>r</tt> so that the injectivity condition for
--   <a>CoOperation</a> can be satisfied.
data NoCoOp r
NoCoOp :: NoCoOp r

-- | <tt><a>OpsConstraint</a> <a>NoEff</a> eff</tt> is just the empty
--   constraint <tt>()</tt> for all <tt>Effect</tt> <tt>eff</tt>. We
--   instead define the empty class <a>NoConstraint</a> with trivial
--   instance for all <tt>Effect</tt> <tt>eff</tt> so that the injectivity
--   condition for <a>OpsConstraint</a> can be satisfied.
class NoConstraint (eff :: Type -> Type)

-- | The <a>Operation</a> of <tt>ops1 <a>∪</a> ops2</tt> undef effect
--   <tt>eff</tt> is the product of the underlying <tt><a>Operation</a>
--   ops1 eff</tt> and <tt><a>Operation</a> ops2 eff</tt>.
data UnionOps ops1 ops2 (eff :: Type -> Type)
UnionOps :: ops1 eff -> ops2 eff -> UnionOps ops1 ops2
infixr 7 `UnionOps`
infixr 7 `UnionOps`

-- | Right associative term operator alias for <a>UnionOps</a>, e.g.
--   
--   <pre>
--   forall ops1 ops2 ops3 .
--     ops1 ∪ ops2 ∪ ops3 === UnionOps ops1 (UnionOps ops2 ops3)
--   </pre>
(∪) :: forall ops1 ops2 eff. ops1 eff -> ops2 eff -> UnionOps ops1 ops2 eff
infixr 7 ∪

-- | The <a>CoOperation</a> of <tt>ops1 <a>∪</a> ops2</tt> under return
--   type <tt>r</tt> is the sum of the underlying <tt><a>CoOperation</a>
--   ops1 r</tt> and <tt><a>CoOperation</a> ops2 r</tt>.
data UnionCoOp ops1 ops2 r
LeftCoOp :: ops1 r -> UnionCoOp ops1 ops2 r
RightCoOp :: ops2 r -> UnionCoOp ops1 ops2 r

-- | Get the left operation of the <tt><a>Operation</a> (ops1 <a>∪</a>
--   ops2)</tt> product.
leftOps :: forall ops1 ops2 eff. UnionOps ops1 ops2 eff -> ops1 eff

-- | Get the right operation of the <tt><a>Operation</a> (ops1 <a>∪</a>
--   ops2)</tt> product.
rightOps :: forall ops1 ops2 eff. UnionOps ops1 ops2 eff -> ops2 eff

-- | An optimized version of <a>LiftEff</a> when there is no effect lifting
--   required, e.g. when we want to execute a <a>Computation</a> with its
--   original effect.
idLift :: forall eff. Effect eff => LiftEff eff eff

-- | Create a <a>LiftEff</a> from a natural transformation <tt>eff1 ~&gt;
--   eff2</tt>. This assumes <tt>eff1</tt> and <tt>eff2</tt> are different,
--   as otherwise we can use <a>idLift</a> for optimized version of
--   <a>LiftEff</a>.
mkLiftEff :: forall eff1 eff2. (Effect eff1, Effect eff2) => (forall x. eff1 x -> eff2 x) -> LiftEff eff1 eff2

-- | The base natural transformation that can be extracted
liftEff :: LiftEff eff1 eff2 -> forall x. eff1 x -> eff2 x

-- | When applying effect lifting to an <a>EffFunctor</a>,
--   <a>applyEffmap</a> should be used instead of calling <a>effmap</a>
--   directly. This could potentially save some unnecesssary objects
--   recreation in the case of <a>idLift</a>.
applyEffmap :: LiftEff eff1 eff2 -> forall comp. EffFunctor comp => comp eff1 -> comp eff2

-- | An optimizable composition of two natural transformations. This makes
--   sure the no new <a>LiftEff</a> is created when either side is
--   <a>idLift</a>. The behavior for <a>joinLift</a> is as follow:
--   
--   <pre>
--   <a>joinLift</a> idLift idLift === idLift
--   <a>joinLift</a> idLift lift2 === lift2
--   <a>joinLift</a> lift1 idLift === lift1
--   <a>joinLift</a> lift1 lift2 === <a>mkLiftEff</a> $ (liftEff lift2) . (liftEff lift1)
--   </pre>
joinLift :: LiftEff eff1 eff2 -> forall eff3. Effect eff3 => LiftEff eff2 eff3 -> LiftEff eff1 eff3

module Control.Effect.Implicit.Computation.Computation
newtype Computation ops comp eff1
Computation :: (forall eff2. (EffOps ops, Effect eff1, Effect eff2) => LiftEff eff1 eff2 -> Operation ops eff2 -> comp eff2) -> Computation ops comp eff1
[runComp] :: Computation ops comp eff1 -> forall eff2. (EffOps ops, Effect eff1, Effect eff2) => LiftEff eff1 eff2 -> Operation ops eff2 -> comp eff2
type Handler ops handler eff = Computation ops (Operation handler) eff
liftComputation :: forall ops comp eff1 eff2. (EffOps ops, Effect eff1, Effect eff2) => LiftEff eff1 eff2 -> Computation ops comp eff1 -> Computation ops comp eff2

module Control.Effect.Implicit.Computation.Cast
data Cast p
Cast :: Cast p
type OpsCast ops1 ops2 = forall eff. (EffConstraint ops1 eff) => Cast (OpsConstraint ops2 eff)
type ops1 ⊇ ops2 = OpsCast ops1 ops2
infixl 6 ⊇
cast :: forall p. p => Cast p
runCast :: forall eff ops1 ops2 r. EffConstraint ops1 eff => (ops1 ⊇ ops2) -> (OpsConstraint ops2 eff => r) -> r
castOps :: forall eff ops1 ops2. (Effect eff, ImplicitOps ops1, ImplicitOps ops2) => (ops1 ⊇ ops2) -> Operation ops1 eff -> Operation ops2 eff
extendCast :: forall ops1 ops2 ops3. (ImplicitOps ops1, ImplicitOps ops2, ImplicitOps ops3) => (ops1 ⊇ ops2) -> (ops1 ∪ ops3) ⊇ (ops2 ∪ ops3)
composeCast :: forall ops1 ops2 ops3. (ImplicitOps ops1, ImplicitOps ops2, ImplicitOps ops3) => (ops1 ⊇ ops2) -> (ops2 ⊇ ops3) -> ops1 ⊇ ops3
castComputation :: forall ops1 ops2 comp eff. (Effect eff, EffOps ops1, EffOps ops2) => (ops1 ⊇ ops2) -> Computation ops2 comp eff -> Computation ops1 comp eff

module Control.Effect.Implicit.Computation.Handler
type BaseHandler handler eff = Handler NoEff handler eff
type GenericHandler ops handler = forall eff. (Effect eff) => Handler ops handler eff
mkHandler :: forall ops handler eff1. (EffOps ops, EffOps handler, Effect eff1) => (forall eff2. EffConstraint ops eff2 => LiftEff eff1 eff2 -> Operation handler eff2) -> Handler ops handler eff1
withHandler :: forall ops handler eff r. (EffOps ops, EffOps handler, EffConstraint ops eff) => Handler ops handler eff -> (OpsConstraint handler eff => r) -> r
baseHandler :: forall handler eff. (EffOps handler, Effect eff) => Operation handler eff -> BaseHandler handler eff
genericHandler :: forall ops handler. (EffOps ops, EffOps handler) => (forall eff. EffConstraint ops eff => Operation handler eff) -> GenericHandler ops handler
bindExactHandler :: forall ops handler eff1 comp. (EffOps ops, EffOps handler, Effect eff1) => Handler ops handler eff1 -> Computation (handler ∪ ops) comp eff1 -> Computation ops comp eff1
composeExactHandlers :: forall ops handler1 handler2 eff1. (EffOps ops, EffOps handler1, EffOps handler2, Effect eff1) => Handler ops handler1 eff1 -> Handler (handler1 ∪ ops) handler2 eff1 -> Handler ops (handler1 ∪ handler2) eff1
castHandler :: forall ops1 ops2 handler eff. (Effect eff, EffOps ops1, EffOps ops2) => (ops1 ⊇ ops2) -> Handler ops2 handler eff -> Handler ops1 handler eff
composeHandlersWithCast :: forall ops1 ops2 ops3 handler1 handler2 eff. (EffOps ops1, EffOps ops2, EffOps ops3, EffOps handler1, EffOps handler2, Effect eff) => (ops3 ⊇ ops1) -> ((handler1 ∪ ops3) ⊇ ops2) -> Handler ops1 handler1 eff -> Handler ops2 handler2 eff -> Handler ops3 (handler1 ∪ handler2) eff
bindHandlerWithCast :: forall ops3 ops1 ops2 handler eff r. (EffOps ops1, EffOps ops2, EffOps ops3, EffOps handler, Effect eff) => (ops3 ⊇ ops1) -> ((handler ∪ ops3) ⊇ ops2) -> Handler ops1 handler eff -> Computation ops2 r eff -> Computation ops3 r eff

module Control.Effect.Implicit.Computation.Pipeline
newtype Pipeline ops1 handler comp1 comp2 eff1 eff2
Pipeline :: (forall ops2. EffOps ops2 => Computation (handler ∪ ops2) comp1 eff1 -> Computation (ops1 ∪ ops2) comp2 eff2) -> Pipeline ops1 handler comp1 comp2 eff1 eff2
[runPipeline] :: Pipeline ops1 handler comp1 comp2 eff1 eff2 -> forall ops2. EffOps ops2 => Computation (handler ∪ ops2) comp1 eff1 -> Computation (ops1 ∪ ops2) comp2 eff2
data TransformerHandler t handler eff
TransformerHandler :: Operation handler (t eff) -> LiftEff eff (t eff) -> LiftEff (t eff) eff -> TransformerHandler t handler eff
[tCoOpHandler] :: TransformerHandler t handler eff -> Operation handler (t eff)
[tLiftEff] :: TransformerHandler t handler eff -> LiftEff eff (t eff)
[tUnliftEff] :: TransformerHandler t handler eff -> LiftEff (t eff) eff
type SimplePipeline ops handler comp eff = Pipeline ops handler comp comp eff eff
type GenericPipeline ops handler eff = forall comp. (EffFunctor comp) => SimplePipeline ops handler comp eff
handlerToPipeline :: forall ops1 handler eff. (Effect eff, EffOps ops1, EffOps handler) => Handler ops1 handler eff -> forall comp. EffFunctor comp => SimplePipeline ops1 handler comp eff
transformerPipeline :: forall t ops1 handler eff1. (Effect eff1, EffOps ops1, EffOps handler, forall eff. Effect eff => Effect (t eff)) => Computation ops1 (TransformerHandler t handler) eff1 -> GenericPipeline ops1 handler eff1
castPipelineOps :: forall ops1 ops2 handler comp1 comp2 eff1 eff2. (Effect eff1, Effect eff2, EffOps ops1, EffOps ops2, EffOps handler) => (ops2 ⊇ ops1) -> Pipeline ops1 handler comp1 comp2 eff1 eff2 -> Pipeline ops2 handler comp1 comp2 eff1 eff2
castPipelineHandler :: forall ops1 handler1 handler2 comp1 comp2 eff1 eff2. (Effect eff1, Effect eff2, EffOps ops1, EffOps handler1, EffOps handler2) => (handler1 ⊇ handler2) -> Pipeline ops1 handler1 comp1 comp2 eff1 eff2 -> Pipeline ops1 handler2 comp1 comp2 eff1 eff2
composePipelines :: forall ops1 ops2 handler1 handler2 comp1 comp2 comp3 eff1 eff2 eff3. (Effect eff1, Effect eff2, Effect eff3, EffOps ops1, EffOps ops2, EffOps handler1, EffOps handler2) => Pipeline (handler2 ∪ ops1) handler1 comp1 comp2 eff1 eff2 -> Pipeline ops2 handler2 comp2 comp3 eff2 eff3 -> Pipeline (ops1 ∪ ops2) (handler1 ∪ handler2) comp1 comp3 eff1 eff3
runPipelineWithCast :: forall ops3 ops1 ops2 handler comp1 comp2 eff1 eff2. (Effect eff1, Effect eff2, EffOps ops1, EffOps ops2, EffOps ops3, EffOps handler) => (ops3 ⊇ ops1) -> ((handler ∪ ops3) ⊇ ops2) -> Pipeline ops1 handler comp1 comp2 eff1 eff2 -> Computation ops2 comp1 eff1 -> Computation ops3 comp2 eff2
composePipelinesWithCast :: forall ops1 ops2 ops3 handler1 handler2 handler3 comp1 comp2 comp3 eff1 eff2 eff3. (Effect eff1, Effect eff2, Effect eff3, EffOps ops1, EffOps ops2, EffOps ops3, EffOps handler1, EffOps handler2, EffOps handler3) => ((handler2 ∪ ops3) ⊇ ops1) -> (ops3 ⊇ ops2) -> ((handler1 ∪ handler2) ⊇ handler3) -> Pipeline ops1 handler1 comp1 comp2 eff1 eff2 -> Pipeline ops2 handler2 comp2 comp3 eff2 eff3 -> Pipeline ops3 handler3 comp1 comp3 eff1 eff3

module Control.Effect.Implicit.Computation.Value
newtype Return a eff
Return :: eff a -> Return a eff
[returnVal] :: Return a eff -> eff a
type GenericReturn ops a = forall eff. (Effect eff) => Computation ops (Return a) eff
type GenericComputation ops comp = forall eff. (Effect eff) => Computation ops comp eff
type IdentityComputation a = Computation NoEff (Return a) Identity
returnComputation :: forall ops a eff1. (Effect eff1, EffOps ops) => (forall eff2. EffConstraint ops eff2 => LiftEff eff1 eff2 -> eff2 a) -> Computation ops (Return a) eff1
genericComputation :: forall ops comp. EffOps ops => (forall eff. EffConstraint ops eff => comp eff) -> forall eff. Effect eff => Computation ops comp eff
genericReturn :: forall ops a. EffOps ops => (forall eff. EffConstraint ops eff => eff a) -> GenericReturn ops a
runIdentityComp :: forall a. IdentityComputation a -> a
execComp :: forall ops eff a. (EffOps ops, EffConstraint ops eff) => Computation ops (Return a) eff -> eff a
instance Control.Effect.Implicit.Base.EffFunctor.EffFunctor (Control.Effect.Implicit.Computation.Value.Return a)

module Control.Effect.Implicit.Computation
newtype Computation ops comp eff1
Computation :: (forall eff2. (EffOps ops, Effect eff1, Effect eff2) => LiftEff eff1 eff2 -> Operation ops eff2 -> comp eff2) -> Computation ops comp eff1
[runComp] :: Computation ops comp eff1 -> forall eff2. (EffOps ops, Effect eff1, Effect eff2) => LiftEff eff1 eff2 -> Operation ops eff2 -> comp eff2
type Handler ops handler eff = Computation ops (Operation handler) eff
newtype Return a eff
Return :: eff a -> Return a eff
[returnVal] :: Return a eff -> eff a
newtype Pipeline ops1 handler comp1 comp2 eff1 eff2
Pipeline :: (forall ops2. EffOps ops2 => Computation (handler ∪ ops2) comp1 eff1 -> Computation (ops1 ∪ ops2) comp2 eff2) -> Pipeline ops1 handler comp1 comp2 eff1 eff2
[runPipeline] :: Pipeline ops1 handler comp1 comp2 eff1 eff2 -> forall ops2. EffOps ops2 => Computation (handler ∪ ops2) comp1 eff1 -> Computation (ops1 ∪ ops2) comp2 eff2
data TransformerHandler t handler eff
TransformerHandler :: Operation handler (t eff) -> LiftEff eff (t eff) -> LiftEff (t eff) eff -> TransformerHandler t handler eff
[tCoOpHandler] :: TransformerHandler t handler eff -> Operation handler (t eff)
[tLiftEff] :: TransformerHandler t handler eff -> LiftEff eff (t eff)
[tUnliftEff] :: TransformerHandler t handler eff -> LiftEff (t eff) eff
data Cast p
Cast :: Cast p
type OpsCast ops1 ops2 = forall eff. (EffConstraint ops1 eff) => Cast (OpsConstraint ops2 eff)
type ops1 ⊇ ops2 = OpsCast ops1 ops2
infixl 6 ⊇
type GenericReturn ops a = forall eff. (Effect eff) => Computation ops (Return a) eff
type GenericComputation ops comp = forall eff. (Effect eff) => Computation ops comp eff
type IdentityComputation a = Computation NoEff (Return a) Identity
type BaseHandler handler eff = Handler NoEff handler eff
type GenericHandler ops handler = forall eff. (Effect eff) => Handler ops handler eff
type SimplePipeline ops handler comp eff = Pipeline ops handler comp comp eff eff
type GenericPipeline ops handler eff = forall comp. (EffFunctor comp) => SimplePipeline ops handler comp eff
returnComputation :: forall ops a eff1. (Effect eff1, EffOps ops) => (forall eff2. EffConstraint ops eff2 => LiftEff eff1 eff2 -> eff2 a) -> Computation ops (Return a) eff1
genericComputation :: forall ops comp. EffOps ops => (forall eff. EffConstraint ops eff => comp eff) -> forall eff. Effect eff => Computation ops comp eff
genericReturn :: forall ops a. EffOps ops => (forall eff. EffConstraint ops eff => eff a) -> GenericReturn ops a
runIdentityComp :: forall a. IdentityComputation a -> a
execComp :: forall ops eff a. (EffOps ops, EffConstraint ops eff) => Computation ops (Return a) eff -> eff a
liftComputation :: forall ops comp eff1 eff2. (EffOps ops, Effect eff1, Effect eff2) => LiftEff eff1 eff2 -> Computation ops comp eff1 -> Computation ops comp eff2
mkHandler :: forall ops handler eff1. (EffOps ops, EffOps handler, Effect eff1) => (forall eff2. EffConstraint ops eff2 => LiftEff eff1 eff2 -> Operation handler eff2) -> Handler ops handler eff1
withHandler :: forall ops handler eff r. (EffOps ops, EffOps handler, EffConstraint ops eff) => Handler ops handler eff -> (OpsConstraint handler eff => r) -> r
baseHandler :: forall handler eff. (EffOps handler, Effect eff) => Operation handler eff -> BaseHandler handler eff
genericHandler :: forall ops handler. (EffOps ops, EffOps handler) => (forall eff. EffConstraint ops eff => Operation handler eff) -> GenericHandler ops handler
bindExactHandler :: forall ops handler eff1 comp. (EffOps ops, EffOps handler, Effect eff1) => Handler ops handler eff1 -> Computation (handler ∪ ops) comp eff1 -> Computation ops comp eff1
composeExactHandlers :: forall ops handler1 handler2 eff1. (EffOps ops, EffOps handler1, EffOps handler2, Effect eff1) => Handler ops handler1 eff1 -> Handler (handler1 ∪ ops) handler2 eff1 -> Handler ops (handler1 ∪ handler2) eff1
handlerToPipeline :: forall ops1 handler eff. (Effect eff, EffOps ops1, EffOps handler) => Handler ops1 handler eff -> forall comp. EffFunctor comp => SimplePipeline ops1 handler comp eff
transformerPipeline :: forall t ops1 handler eff1. (Effect eff1, EffOps ops1, EffOps handler, forall eff. Effect eff => Effect (t eff)) => Computation ops1 (TransformerHandler t handler) eff1 -> GenericPipeline ops1 handler eff1
composePipelines :: forall ops1 ops2 handler1 handler2 comp1 comp2 comp3 eff1 eff2 eff3. (Effect eff1, Effect eff2, Effect eff3, EffOps ops1, EffOps ops2, EffOps handler1, EffOps handler2) => Pipeline (handler2 ∪ ops1) handler1 comp1 comp2 eff1 eff2 -> Pipeline ops2 handler2 comp2 comp3 eff2 eff3 -> Pipeline (ops1 ∪ ops2) (handler1 ∪ handler2) comp1 comp3 eff1 eff3
cast :: forall p. p => Cast p
runCast :: forall eff ops1 ops2 r. EffConstraint ops1 eff => (ops1 ⊇ ops2) -> (OpsConstraint ops2 eff => r) -> r
castOps :: forall eff ops1 ops2. (Effect eff, ImplicitOps ops1, ImplicitOps ops2) => (ops1 ⊇ ops2) -> Operation ops1 eff -> Operation ops2 eff
castComputation :: forall ops1 ops2 comp eff. (Effect eff, EffOps ops1, EffOps ops2) => (ops1 ⊇ ops2) -> Computation ops2 comp eff -> Computation ops1 comp eff
castHandler :: forall ops1 ops2 handler eff. (Effect eff, EffOps ops1, EffOps ops2) => (ops1 ⊇ ops2) -> Handler ops2 handler eff -> Handler ops1 handler eff
bindHandlerWithCast :: forall ops3 ops1 ops2 handler eff r. (EffOps ops1, EffOps ops2, EffOps ops3, EffOps handler, Effect eff) => (ops3 ⊇ ops1) -> ((handler ∪ ops3) ⊇ ops2) -> Handler ops1 handler eff -> Computation ops2 r eff -> Computation ops3 r eff
composeHandlersWithCast :: forall ops1 ops2 ops3 handler1 handler2 eff. (EffOps ops1, EffOps ops2, EffOps ops3, EffOps handler1, EffOps handler2, Effect eff) => (ops3 ⊇ ops1) -> ((handler1 ∪ ops3) ⊇ ops2) -> Handler ops1 handler1 eff -> Handler ops2 handler2 eff -> Handler ops3 (handler1 ∪ handler2) eff
extendCast :: forall ops1 ops2 ops3. (ImplicitOps ops1, ImplicitOps ops2, ImplicitOps ops3) => (ops1 ⊇ ops2) -> (ops1 ∪ ops3) ⊇ (ops2 ∪ ops3)
composeCast :: forall ops1 ops2 ops3. (ImplicitOps ops1, ImplicitOps ops2, ImplicitOps ops3) => (ops1 ⊇ ops2) -> (ops2 ⊇ ops3) -> ops1 ⊇ ops3
runPipelineWithCast :: forall ops3 ops1 ops2 handler comp1 comp2 eff1 eff2. (Effect eff1, Effect eff2, EffOps ops1, EffOps ops2, EffOps ops3, EffOps handler) => (ops3 ⊇ ops1) -> ((handler ∪ ops3) ⊇ ops2) -> Pipeline ops1 handler comp1 comp2 eff1 eff2 -> Computation ops2 comp1 eff1 -> Computation ops3 comp2 eff2
castPipelineOps :: forall ops1 ops2 handler comp1 comp2 eff1 eff2. (Effect eff1, Effect eff2, EffOps ops1, EffOps ops2, EffOps handler) => (ops2 ⊇ ops1) -> Pipeline ops1 handler comp1 comp2 eff1 eff2 -> Pipeline ops2 handler comp1 comp2 eff1 eff2
castPipelineHandler :: forall ops1 handler1 handler2 comp1 comp2 eff1 eff2. (Effect eff1, Effect eff2, EffOps ops1, EffOps handler1, EffOps handler2) => (handler1 ⊇ handler2) -> Pipeline ops1 handler1 comp1 comp2 eff1 eff2 -> Pipeline ops1 handler2 comp1 comp2 eff1 eff2
composePipelinesWithCast :: forall ops1 ops2 ops3 handler1 handler2 handler3 comp1 comp2 comp3 eff1 eff2 eff3. (Effect eff1, Effect eff2, Effect eff3, EffOps ops1, EffOps ops2, EffOps ops3, EffOps handler1, EffOps handler2, EffOps handler3) => ((handler2 ∪ ops3) ⊇ ops1) -> (ops3 ⊇ ops2) -> ((handler1 ∪ handler2) ⊇ handler3) -> Pipeline ops1 handler1 comp1 comp2 eff1 eff2 -> Pipeline ops2 handler2 comp2 comp3 eff2 eff3 -> Pipeline ops3 handler3 comp1 comp3 eff1 eff3

module Control.Effect.Implicit.Free.FreeEff
class (forall ops eff. (FreeOps ops, Effect eff) => Monad (free ops eff)) => FreeEff free
freeOps :: forall ops eff. (FreeEff free, FreeOps ops, Effect eff) => Operation ops (free ops eff)
liftFree :: forall ops eff a. (FreeEff free, FreeOps ops, Effect eff) => eff a -> free ops eff a
handleFree :: forall ops eff a r. (FreeEff free, Effect eff, FreeOps ops) => CoOpHandler ops a r eff -> free ops eff a -> eff r
class (FreeEff free) => FreerEff free
handleFreer :: forall ops eff a r. (FreerEff free, Effect eff, FreeOps ops) => FreerCoOpHandler ops a r eff -> free ops eff a -> eff r
data CoOpHandler handler a r eff
CoOpHandler :: (a -> eff r) -> (CoOperation handler (eff r) -> eff r) -> CoOpHandler handler a r eff
[handleFreeReturn] :: CoOpHandler handler a r eff -> a -> eff r
[handleFreeCoOp] :: CoOpHandler handler a r eff -> CoOperation handler (eff r) -> eff r
data FreerCoOpHandler handler a r eff
FreerCoOpHandler :: (a -> eff r) -> (forall x. CoOperation handler x -> (x -> eff r) -> eff r) -> FreerCoOpHandler handler a r eff
[handleFreerReturn] :: FreerCoOpHandler handler a r eff -> a -> eff r
[handleFreerCoOp] :: FreerCoOpHandler handler a r eff -> forall x. CoOperation handler x -> (x -> eff r) -> eff r
newtype GenericCoOpHandler handler eff
GenericCoOpHandler :: (forall a. CoOpHandler handler a a eff) -> GenericCoOpHandler handler eff
data ContextualHandler w handler eff
ContextualHandler :: (forall a. CoOpHandler handler a (w eff a) eff) -> (forall a. w eff a -> eff a) -> ContextualHandler w handler eff
[runContextualHandler] :: ContextualHandler w handler eff -> forall a. CoOpHandler handler a (w eff a) eff
[extractResult] :: ContextualHandler w handler eff -> forall a. w eff a -> eff a
freeLiftEff :: forall free ops eff. (FreeEff free, FreeOps ops, Effect eff) => LiftEff eff (free ops eff)

module Control.Effect.Implicit.Free.Free
newtype FreeMonad ops eff a
FreeMonad :: FreeT (CoOperation ops) eff a -> FreeMonad ops eff a
[unFreeT] :: FreeMonad ops eff a -> FreeT (CoOperation ops) eff a
instance (Control.Effect.Implicit.Base.FreeOps.FreeOps ops, GHC.Base.Monad eff) => GHC.Base.Functor (Control.Effect.Implicit.Free.Free.FreeMonad ops eff)
instance (Control.Effect.Implicit.Base.FreeOps.FreeOps ops, GHC.Base.Monad eff) => GHC.Base.Applicative (Control.Effect.Implicit.Free.Free.FreeMonad ops eff)
instance (Control.Effect.Implicit.Base.FreeOps.FreeOps ops, GHC.Base.Monad eff) => GHC.Base.Monad (Control.Effect.Implicit.Free.Free.FreeMonad ops eff)
instance Control.Effect.Implicit.Free.FreeEff.FreeEff Control.Effect.Implicit.Free.Free.FreeMonad

module Control.Effect.Implicit.Free.Freer
newtype FreerMonad ops eff a
FreerMonad :: eff (FreerF ops a (FreerMonad ops eff a)) -> FreerMonad ops eff a
[runFreerMonad] :: FreerMonad ops eff a -> eff (FreerF ops a (FreerMonad ops eff a))
data FreerF ops a b
[PureF] :: forall ops a b. a -> FreerF ops a b
[FreeF] :: forall ops a b x. CoOperation ops x -> (x -> b) -> FreerF ops a b
instance (GHC.Base.Monad eff, Control.Effect.Implicit.Base.FreeOps.FreeOps ops) => GHC.Base.Functor (Control.Effect.Implicit.Free.Freer.FreerMonad ops eff)
instance (GHC.Base.Monad eff, Control.Effect.Implicit.Base.FreeOps.FreeOps ops) => GHC.Base.Applicative (Control.Effect.Implicit.Free.Freer.FreerMonad ops eff)
instance (GHC.Base.Monad eff, Control.Effect.Implicit.Base.FreeOps.FreeOps ops) => GHC.Base.Monad (Control.Effect.Implicit.Free.Freer.FreerMonad ops eff)
instance Control.Effect.Implicit.Free.FreeEff.FreeEff Control.Effect.Implicit.Free.Freer.FreerMonad
instance Control.Effect.Implicit.Free.FreeEff.FreerEff Control.Effect.Implicit.Free.Freer.FreerMonad

module Control.Effect.Implicit.Free.Handler
withCoOpHandler :: forall free handler eff a r. (Effect eff, EffOps handler, FreeEff free) => CoOpHandler handler a r eff -> (OpsConstraint handler (free handler eff) => free handler eff a) -> eff r
withCoOpHandlerAndOps :: forall free ops handler eff a r. (EffOps ops, EffOps handler, FreeEff free, EffConstraint ops eff) => CoOpHandler handler a r eff -> ((OpsConstraint handler (free handler eff), OpsConstraint ops (free handler eff)) => free handler eff a) -> eff r
withFreerCoOpHandler :: forall free ops eff a r. (Effect eff, EffOps ops, FreerEff free) => FreerCoOpHandler ops a r eff -> (OpsConstraint ops (free ops eff) => free ops eff a) -> eff r
withContextualCoOpHandler :: forall free ops eff a r. (Effect eff, EffOps ops, FreeEff free) => CoOpHandler ops a r eff -> (r -> eff a) -> (OpsConstraint ops (free ops eff) => free ops eff a) -> eff a

module Control.Effect.Implicit.Free.Pipeline
coopHandlerToPipeline :: forall free ops1 handler eff1 a b. (Effect eff1, EffOps ops1, EffOps handler, FreeEff free) => Computation ops1 (CoOpHandler handler a b) eff1 -> Pipeline ops1 handler (Return a) (Return b) eff1 eff1
genericCoOpHandlerToPipeline :: forall free ops1 handler eff1. (Effect eff1, EffOps ops1, EffOps handler, FreeEff free) => Computation ops1 (GenericCoOpHandler handler) eff1 -> GenericPipeline ops1 handler eff1
contextualHandlerToPipeline :: forall free w ops1 handler eff1. (Effect eff1, EffOps ops1, EffOps handler, FreeEff free) => Computation ops1 (ContextualHandler w handler) eff1 -> GenericPipeline ops1 handler eff1

module Control.Effect.Implicit.Free
data CoOpHandler handler a r eff
CoOpHandler :: (a -> eff r) -> (CoOperation handler (eff r) -> eff r) -> CoOpHandler handler a r eff
[handleFreeReturn] :: CoOpHandler handler a r eff -> a -> eff r
[handleFreeCoOp] :: CoOpHandler handler a r eff -> CoOperation handler (eff r) -> eff r
class (forall ops eff. (FreeOps ops, Effect eff) => Monad (free ops eff)) => FreeEff free
freeOps :: forall ops eff. (FreeEff free, FreeOps ops, Effect eff) => Operation ops (free ops eff)
liftFree :: forall ops eff a. (FreeEff free, FreeOps ops, Effect eff) => eff a -> free ops eff a
handleFree :: forall ops eff a r. (FreeEff free, Effect eff, FreeOps ops) => CoOpHandler ops a r eff -> free ops eff a -> eff r
newtype ChurchMonad ops eff a
ChurchMonad :: (forall r. CoOpHandler ops a r eff -> eff r) -> ChurchMonad ops eff a
[runChurchMonad] :: ChurchMonad ops eff a -> forall r. CoOpHandler ops a r eff -> eff r
newtype FreeMonad ops eff a
FreeMonad :: FreeT (CoOperation ops) eff a -> FreeMonad ops eff a
[unFreeT] :: FreeMonad ops eff a -> FreeT (CoOperation ops) eff a
newtype GenericCoOpHandler handler eff
GenericCoOpHandler :: (forall a. CoOpHandler handler a a eff) -> GenericCoOpHandler handler eff
data ContextualHandler w handler eff
ContextualHandler :: (forall a. CoOpHandler handler a (w eff a) eff) -> (forall a. w eff a -> eff a) -> ContextualHandler w handler eff
[runContextualHandler] :: ContextualHandler w handler eff -> forall a. CoOpHandler handler a (w eff a) eff
[extractResult] :: ContextualHandler w handler eff -> forall a. w eff a -> eff a
data FreerCoOpHandler handler a r eff
FreerCoOpHandler :: (a -> eff r) -> (forall x. CoOperation handler x -> (x -> eff r) -> eff r) -> FreerCoOpHandler handler a r eff
[handleFreerReturn] :: FreerCoOpHandler handler a r eff -> a -> eff r
[handleFreerCoOp] :: FreerCoOpHandler handler a r eff -> forall x. CoOperation handler x -> (x -> eff r) -> eff r
class (FreeEff free) => FreerEff free
handleFreer :: forall ops eff a r. (FreerEff free, Effect eff, FreeOps ops) => FreerCoOpHandler ops a r eff -> free ops eff a -> eff r
newtype FreerMonad ops eff a
FreerMonad :: eff (FreerF ops a (FreerMonad ops eff a)) -> FreerMonad ops eff a
[runFreerMonad] :: FreerMonad ops eff a -> eff (FreerF ops a (FreerMonad ops eff a))
data FreerF ops a b
[PureF] :: forall ops a b. a -> FreerF ops a b
[FreeF] :: forall ops a b x. CoOperation ops x -> (x -> b) -> FreerF ops a b
freeLiftEff :: forall free ops eff. (FreeEff free, FreeOps ops, Effect eff) => LiftEff eff (free ops eff)
withCoOpHandler :: forall free handler eff a r. (Effect eff, EffOps handler, FreeEff free) => CoOpHandler handler a r eff -> (OpsConstraint handler (free handler eff) => free handler eff a) -> eff r
withCoOpHandlerAndOps :: forall free ops handler eff a r. (EffOps ops, EffOps handler, FreeEff free, EffConstraint ops eff) => CoOpHandler handler a r eff -> ((OpsConstraint handler (free handler eff), OpsConstraint ops (free handler eff)) => free handler eff a) -> eff r
withFreerCoOpHandler :: forall free ops eff a r. (Effect eff, EffOps ops, FreerEff free) => FreerCoOpHandler ops a r eff -> (OpsConstraint ops (free ops eff) => free ops eff a) -> eff r
withContextualCoOpHandler :: forall free ops eff a r. (Effect eff, EffOps ops, FreeEff free) => CoOpHandler ops a r eff -> (r -> eff a) -> (OpsConstraint ops (free ops eff) => free ops eff a) -> eff a
coopHandlerToPipeline :: forall free ops1 handler eff1 a b. (Effect eff1, EffOps ops1, EffOps handler, FreeEff free) => Computation ops1 (CoOpHandler handler a b) eff1 -> Pipeline ops1 handler (Return a) (Return b) eff1 eff1
genericCoOpHandlerToPipeline :: forall free ops1 handler eff1. (Effect eff1, EffOps ops1, EffOps handler, FreeEff free) => Computation ops1 (GenericCoOpHandler handler) eff1 -> GenericPipeline ops1 handler eff1
contextualHandlerToPipeline :: forall free w ops1 handler eff1. (Effect eff1, EffOps ops1, EffOps handler, FreeEff free) => Computation ops1 (ContextualHandler w handler) eff1 -> GenericPipeline ops1 handler eff1

module Control.Effect.Implicit.Ops.Decide
data DecideEff s
data DecideOps s eff
DecideOps :: eff s -> DecideOps s eff
[decideOp] :: DecideOps s eff -> eff s
data DecideCoOp s a
DecideOp :: (s -> a) -> DecideCoOp s a
type DecideConstraint s eff = (?decideOps :: DecideOps s eff)
decide :: forall a eff. DecideConstraint a eff => eff a
instance GHC.Base.Functor (Control.Effect.Implicit.Ops.Decide.DecideCoOp s)
instance Control.Effect.Implicit.Base.Implicit.ImplicitOps (Control.Effect.Implicit.Ops.Decide.DecideEff s)
instance Control.Effect.Implicit.Base.EffSpec.EffSpec (Control.Effect.Implicit.Ops.Decide.DecideEff s)
instance Control.Effect.Implicit.Base.FreeOps.FreeOps (Control.Effect.Implicit.Ops.Decide.DecideEff s)
instance Control.Effect.Implicit.Base.EffFunctor.EffFunctor (Control.Effect.Implicit.Ops.Decide.DecideOps s)

module Control.Effect.Implicit.Ops.Env
data EnvEff e
data EnvOps e eff
EnvOps :: eff e -> EnvOps e eff
[askOp] :: EnvOps e eff -> eff e
data EnvCoOp e r
AskOp :: (e -> r) -> EnvCoOp e r
type EnvConstraint e eff = (?envOps :: EnvOps e eff)
ask :: forall e eff. EnvConstraint e eff => eff e
withEnv :: forall r e eff. Effect eff => e -> (EnvConstraint e eff => eff r) -> eff r
mkEnvOps :: forall e eff. Effect eff => e -> EnvOps e eff
mkEnvHandler :: forall e eff. Effect eff => e -> BaseHandler (EnvEff e) eff
instance Control.Effect.Implicit.Base.Implicit.ImplicitOps (Control.Effect.Implicit.Ops.Env.EnvEff e)
instance Control.Effect.Implicit.Base.EffSpec.EffSpec (Control.Effect.Implicit.Ops.Env.EnvEff e)
instance GHC.Base.Functor (Control.Effect.Implicit.Ops.Env.EnvCoOp e)
instance Control.Effect.Implicit.Base.FreeOps.FreeOps (Control.Effect.Implicit.Ops.Env.EnvEff e)
instance Control.Effect.Implicit.Base.EffFunctor.EffFunctor (Control.Effect.Implicit.Ops.Env.EnvOps e)

module Control.Effect.Implicit.Ops.Io
data IoEff
data IoOps eff
IoOps :: (forall a. IO a -> eff a) -> IoOps eff
[liftIoOp] :: IoOps eff -> forall a. IO a -> eff a
data IoCoOp a
[IoCoOp] :: forall x a. IO x -> (x -> a) -> IoCoOp a
type IoConstraint eff = (?ioOps :: IoOps eff)
liftIo :: forall a eff. IoConstraint eff => IO a -> eff a
ioOps :: IoOps IO
ioHandler :: BaseHandler IoEff IO
instance Control.Effect.Implicit.Base.Implicit.ImplicitOps Control.Effect.Implicit.Ops.Io.IoEff
instance Control.Effect.Implicit.Base.EffSpec.EffSpec Control.Effect.Implicit.Ops.Io.IoEff
instance GHC.Base.Functor Control.Effect.Implicit.Ops.Io.IoCoOp
instance Control.Effect.Implicit.Base.FreeOps.FreeOps Control.Effect.Implicit.Ops.Io.IoEff
instance Control.Effect.Implicit.Base.EffFunctor.EffFunctor Control.Effect.Implicit.Ops.Io.IoOps

module Control.Effect.Implicit.Ops.Exception
data ExceptionEff e
data ExceptionOps e eff
ExceptionOps :: (e -> eff Void) -> ExceptionOps e eff
[raiseOp] :: ExceptionOps e eff -> e -> eff Void
data ExceptionCoOp e r
RaiseOp :: e -> ExceptionCoOp e r
type ExceptionConstraint e eff = (?exceptionOps :: ExceptionOps e eff)
raise :: forall e a eff. (Effect eff, ExceptionConstraint e eff) => e -> eff a
mkExceptionCoOpHandler :: forall eff e a. Effect eff => (e -> eff a) -> CoOpHandler (ExceptionEff e) a a eff
exceptionToEitherHandler :: forall eff e a. Effect eff => CoOpHandler (ExceptionEff e) a (Either e a) eff
tryIo :: forall eff e a. (Exception e, EffConstraint (IoEff ∪ ExceptionEff e) eff) => IO a -> eff a
tryIoHandler :: forall e eff. (Effect eff, Exception e) => Handler (ExceptionEff e ∪ IoEff) IoEff eff
try :: forall free eff e a. (Effect eff, FreeEff free) => (OpsConstraint (ExceptionEff e) (free (ExceptionEff e) eff) => free (ExceptionEff e) eff a) -> (e -> eff a) -> eff a
tryFinally :: forall free eff e a. (FreeEff free, EffConstraint (ExceptionEff e) eff) => (OpsConstraint (ExceptionEff e) (free (ExceptionEff e) eff) => free (ExceptionEff e) eff a) -> (() -> eff ()) -> eff a
tryComp :: forall free eff ops e a. (FreeEff free, EffOps ops, EffConstraint ops eff) => Computation (ExceptionEff e ∪ ops) (Return a) eff -> (e -> eff a) -> eff a
bracketComp :: forall free eff ops e a b. (FreeEff free, EffOps ops, EffConstraint ops eff) => Computation (ExceptionEff e ∪ ops) (Return a) eff -> (a -> Computation (ExceptionEff e ∪ ops) (Return ()) eff) -> (a -> Computation (ExceptionEff e ∪ ops) (Return b) eff) -> Computation (ExceptionEff e ∪ ops) (Return b) eff
instance Control.Effect.Implicit.Base.Implicit.ImplicitOps (Control.Effect.Implicit.Ops.Exception.ExceptionEff e)
instance Control.Effect.Implicit.Base.EffSpec.EffSpec (Control.Effect.Implicit.Ops.Exception.ExceptionEff e)
instance GHC.Base.Functor (Control.Effect.Implicit.Ops.Exception.ExceptionCoOp e)
instance Control.Effect.Implicit.Base.FreeOps.FreeOps (Control.Effect.Implicit.Ops.Exception.ExceptionEff e)
instance Control.Effect.Implicit.Base.EffFunctor.EffFunctor (Control.Effect.Implicit.Ops.Exception.ExceptionOps e)

module Control.Effect.Implicit.Ops.Async
data AsyncEff (t :: Type -> Type)
data AsyncOps t eff
AsyncOps :: (forall a. t a -> eff a) -> (forall a. [t a] -> eff [a]) -> AsyncOps t eff
[awaitOp] :: AsyncOps t eff -> forall a. t a -> eff a
[awaitAllOp] :: AsyncOps t eff -> forall a. [t a] -> eff [a]
data AsyncCoOp t r
[AwaitOp] :: forall t r a. t a -> (a -> r) -> AsyncCoOp t r
[AwaitAllOp] :: forall t r a. [t a] -> ([a] -> r) -> AsyncCoOp t r
type AsyncConstraint t eff = (?asyncOps :: AsyncOps t eff)
await :: forall a t eff. (Effect eff, AsyncConstraint t eff) => t a -> eff a
awaitAll :: forall a t eff. (Effect eff, AsyncConstraint t eff) => [t a] -> eff [a]
handleAsync :: forall free eff a t. (FreeEff free, EffConstraint IoEff eff) => (forall x. AsyncConstraint t (free (AsyncEff t) IO) => t x -> free (AsyncEff t) IO x) -> (AsyncConstraint t (free (AsyncEff t) eff) => free (AsyncEff t) eff a) -> eff a
instance Control.Effect.Implicit.Base.Implicit.ImplicitOps (Control.Effect.Implicit.Ops.Async.AsyncEff t)
instance Control.Effect.Implicit.Base.EffSpec.EffSpec (Control.Effect.Implicit.Ops.Async.AsyncEff t)
instance GHC.Base.Functor (Control.Effect.Implicit.Ops.Async.AsyncCoOp t)
instance Control.Effect.Implicit.Base.FreeOps.FreeOps (Control.Effect.Implicit.Ops.Async.AsyncEff t)
instance Control.Effect.Implicit.Base.EffFunctor.EffFunctor (Control.Effect.Implicit.Ops.Async.AsyncOps t)

module Control.Effect.Implicit.Ops.State
data StateEff s
data StateOps s eff
StateOps :: eff s -> (s -> eff ()) -> StateOps s eff
[getOp] :: StateOps s eff -> eff s
[putOp] :: StateOps s eff -> s -> eff ()
data StateCoOp s a
GetOp :: (s -> a) -> StateCoOp s a
PutOp :: s -> (() -> a) -> StateCoOp s a
type StateConstraint s eff = (?stateOps :: StateOps s eff)
get :: forall a eff. StateConstraint a eff => eff a
put :: forall a eff. StateConstraint a eff => a -> eff ()
instance Control.Effect.Implicit.Base.Implicit.ImplicitOps (Control.Effect.Implicit.Ops.State.StateEff s)
instance Control.Effect.Implicit.Base.EffSpec.EffSpec (Control.Effect.Implicit.Ops.State.StateEff s)
instance GHC.Base.Functor (Control.Effect.Implicit.Ops.State.StateCoOp s)
instance Control.Effect.Implicit.Base.FreeOps.FreeOps (Control.Effect.Implicit.Ops.State.StateEff s)
instance Control.Effect.Implicit.Base.EffFunctor.EffFunctor (Control.Effect.Implicit.Ops.State.StateOps a)

module Control.Effect.Implicit.Ops.Log
data LogEff l
data LogOps l eff
LogOps :: (l -> eff ()) -> LogOps l eff
[logOp] :: LogOps l eff -> l -> eff ()
data LogCoOp l r
LogOp :: l -> (() -> r) -> LogCoOp l r
type LogConstraint l eff = (?logOps :: LogOps l eff)
log :: forall l eff. (Effect eff, LogConstraint l eff) => l -> eff ()
stateLoggerHandler :: forall l eff. Effect eff => Handler (StateEff [l]) (LogEff l) eff
printLoggerHandler :: forall a eff. (Effect eff, Show a) => Handler IoEff (LogEff a) eff
instance GHC.Base.Functor (Control.Effect.Implicit.Ops.Log.LogCoOp l)
instance Control.Effect.Implicit.Base.Implicit.ImplicitOps (Control.Effect.Implicit.Ops.Log.LogEff l)
instance Control.Effect.Implicit.Base.EffSpec.EffSpec (Control.Effect.Implicit.Ops.Log.LogEff l)
instance Control.Effect.Implicit.Base.FreeOps.FreeOps (Control.Effect.Implicit.Ops.Log.LogEff l)
instance Control.Effect.Implicit.Base.EffFunctor.EffFunctor (Control.Effect.Implicit.Ops.Log.LogOps l)

module Control.Effect.Implicit.Ops

module Control.Effect.Implicit.TaggedOps.TaggedEff
data TaggedEff l ops
data TaggedOps :: forall k. k -> ((Type -> Type) -> Type) -> (Type -> Type) -> Type
[TaggedOps] :: forall l ops eff. ops eff -> TaggedOps l ops eff
data TaggedCoOp :: forall k. k -> (Type -> Type) -> Type -> Type
[TaggedCoOp] :: forall l coop r. coop r -> TaggedCoOp l coop r
untagOps :: forall l ops eff. TaggedOps l ops eff -> ops eff
untagCoOp :: forall l coop r. TaggedCoOp l coop r -> coop r
withTag :: forall l ops eff r. (EffOps ops, EffOps (TaggedEff l ops), EffConstraint (TaggedEff l ops) eff) => (OpsConstraint ops eff => r) -> r
instance forall k ops (l :: k). Control.Effect.Implicit.Base.EffSpec.EffSpec ops => Control.Effect.Implicit.Base.EffSpec.EffSpec (Control.Effect.Implicit.TaggedOps.TaggedEff.TaggedEff l ops)
instance forall k (coop :: * -> *) (l :: k). GHC.Base.Functor coop => GHC.Base.Functor (Control.Effect.Implicit.TaggedOps.TaggedEff.TaggedCoOp l coop)
instance forall k ops (l :: k). Control.Effect.Implicit.Base.FreeOps.FreeOps ops => Control.Effect.Implicit.Base.FreeOps.FreeOps (Control.Effect.Implicit.TaggedOps.TaggedEff.TaggedEff l ops)
instance forall k (ops :: (* -> *) -> *) (l :: k). Control.Effect.Implicit.Base.EffFunctor.EffFunctor ops => Control.Effect.Implicit.Base.EffFunctor.EffFunctor (Control.Effect.Implicit.TaggedOps.TaggedEff.TaggedOps l ops)

module Control.Effect.Implicit.TaggedOps.Env
type TaggedEnvEff tag e = TaggedEff tag (EnvEff e)
type TaggedEnvOps tag e eff = TaggedOps tag (EnvOps e) eff
type TaggedEnvCoOp tag e r = TaggedCoOp tag (EnvCoOp e) r
askTag :: forall tag e eff. (EffOps (TaggedEnvEff tag e), EffConstraint (TaggedEnvEff tag e) eff) => eff e
mkTaggedEnvOps :: forall tag e eff. Effect eff => e -> TaggedEnvOps tag e eff

module Control.Effect.Implicit.TaggedOps
data TaggedEff l ops
data TaggedOps :: forall k. k -> ((Type -> Type) -> Type) -> (Type -> Type) -> Type
[TaggedOps] :: forall l ops eff. ops eff -> TaggedOps l ops eff
data TaggedCoOp :: forall k. k -> (Type -> Type) -> Type -> Type
[TaggedCoOp] :: forall l coop r. coop r -> TaggedCoOp l coop r
untagOps :: forall l ops eff. TaggedOps l ops eff -> ops eff
untagCoOp :: forall l coop r. TaggedCoOp l coop r -> coop r
withTag :: forall l ops eff r. (EffOps ops, EffOps (TaggedEff l ops), EffConstraint (TaggedEff l ops) eff) => (OpsConstraint ops eff => r) -> r

module Control.Effect.Implicit.Transform.Reader
liftReaderT :: forall a eff. Effect eff => LiftEff eff (ReaderT a eff)
readerTOps :: forall a eff. Effect eff => EnvOps a (ReaderT a eff)
readerTHandler :: forall a eff. Effect eff => Handler NoEff (EnvEff a) (ReaderT a eff)

module Control.Effect.Implicit.Transform.State
liftStateT :: forall s eff. Effect eff => LiftEff eff (StateT s eff)
stateTOps :: forall eff s. Effect eff => StateOps s (StateT s eff)
stateTHandler :: forall eff s. Effect eff => Handler NoEff (StateEff s) (StateT s eff)
stateTPipeline :: forall s eff1 comp. (Effect eff1, EffFunctor comp) => SimplePipeline (EnvEff s) (StateEff s) comp eff1

module Control.Effect.Implicit.Transform


-- | This is the main module for implicit-effects. It re-exports the
--   majority of the submodules offered by this package, other than
--   <a>Control.Effect.Implicit.Ops</a>.* and
--   <a>Control.Effect.Implicit.TaggedOps</a>.*. Refer the submodules for
--   complete documentation.
module Control.Effect.Implicit

module Paths_implicit_effects
version :: Version
getBinDir :: IO FilePath
getLibDir :: IO FilePath
getDynLibDir :: IO FilePath
getDataDir :: IO FilePath
getLibexecDir :: IO FilePath
getDataFileName :: FilePath -> IO FilePath
getSysconfDir :: IO FilePath
